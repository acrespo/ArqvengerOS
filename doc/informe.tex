\documentclass[a4paper,10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{t1enc}
\usepackage[spanish]{babel}
\usepackage[pdftex,usenames,dvipsnames]{color}
\usepackage[pdftex]{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\lstset{language=C}
\lstset{showstringspaces=false}
\lstset{basicstyle=\ttfamily,}

\begin{document}


\renewcommand{\lstlistingname}{C\'odigo Fuente}
\lstloadlanguages{Octave} 
\lstdefinelanguage{MyPseudoCode}[]{Octave}{
	deletekeywords={beta,det},
	morekeywords={repmat}
} 
\lstset{
	language=MyPseudoCode,
	stringstyle=\ttfamily,
	showstringspaces = false,
	basicstyle=\footnotesize\ttfamily,
	commentstyle=\color{gray},
	keywordstyle=\bfseries,
	numbers=left,
	numberstyle=\ttfamily\footnotesize,
	stepnumber=1,                   
	framexleftmargin=0.20cm,
	numbersep=0.37cm,              
	backgroundcolor=\color{white},
	showspaces=false,
	showtabs=false,
	frame=l,
	tabsize=4,
	captionpos=b,               
	breaklines=true,             
	breakatwhitespace=false,      
	mathescape=true
}
\begin{titlepage}
        \thispagestyle{empty}
        \begin{center}
                \includegraphics{./images/itba.jpg}
                \vfill
                \Huge{Sistemas Operativos}\\
                \vspace{1cm}
                \huge{Trabajo Práctico Especial}\\
        \end{center}
        \vspace{2cm}
        \large{
                \begin{tabular}{lcrc}
                        \textbf{Alvaro Crespo} & & 50758 & \ \ \texttt{acrespo@alu.itba.edu.ar}\\
                        \textbf{Juan Pablo Civile} & & 50453 & \ \ \texttt{jcivile@alu.itba.edu.ar}\\
                        \textbf{Darío Susnisky} & & 50592 & \ \ \texttt{dsusnisk@alu.itba.edu.ar}\\
                        \\ 
                \end{tabular}
        }
        \vfill
        \flushright{24 de Octubre del 2011}
\end{titlepage}

\setcounter{page}{1}

\tableofcontents
\newpage
\section{Introducción}
El trabajo práctico consistía en la extensión del sistema operativo armado en la materia arquitectura de las 
computadoras. Este debia ser modificado de modo tal que esta nueva versión soporte procesamiento multitareas
 (inclusive con más de una técnica de 	extit{scheduling}), soporte de acceso a disco rígido y un \textit{file system}
 no tan básico con varios detalles interesantes (soporte de usuarios y grupos, \textit{FIFO's}, entre otros).

\newpage
\section{Breve resumen de la vieja versión de Arqvengers OS}
El trabajo práctico fue comenzado tomando como base el trabajo hecho en la materia Arquitectura de las Computadoras.
 Este trabajo contaba con un sistema operativo booteable que contaba con soporte para \textit{drivers} de
  teclado y de video facilitando varias consolas en donde podían ejecutarse distintos comandos. 
  A un nivel más bajo, contabamos con una rudimentaria e incompleta librería de C así como una interfaz para realizar
  llamadas a sistema.
\newpage
\section{Procesos}
    Al comenzar el nuevo trabajo práctico, uno de los primeros desafios era el de implementar un sistema multitarea.
     En un principio, se diseñaron estructuras adecuadas para poder contener toda la información que formaba a un proceso,
      así como los datos necesarios para poder recuperar los estados de un proceso a la hora de ser ejecutados
      por el procesador. En esta instancia fue aprovechado el diseño de estas estructuras para agregarle ciertas
      funcionalidades a los procesos, como por ejemplo usuarios y grupos.
     La jerarquía de los procesos fue modelada de forma similar a la de \textit{UNIX} y una vez preparados los datos
      necesarios se utilizó el uso de llamadas como \textit{run()} (función análoga a lo que era \textit{fork()} y
      \textit{exec()} en un entorno \textit{UNIX}) para la creación de estos procesos.

    \subsection{Estructura de un proceso}
    
    La estructura de un proceso necesitaba tener la información justa y necesaria para que una vez creado pueda ser 
    ejecutado en un ambiente multitarea, con un \textit{file system} y con manejo de archivos. La llamada a 
    \textit{run()} también debía ser soportada por estos procesos.

    Finalmente la estructura de un proceso conto con su identificador de proceso, datos sobre el proceso padre, datos
    sobre el punto de entrada del proceso junto con sus argumentos y datos en memoria, datos sobre el estado de ejecución
    del proceso junto con otros datos de \textit{scheduling}, información sobre el tiempo de ejecución, una tabla de
    los archivos abiertos por el proceso, datos sobre el grupo y usuario que ejecutó el proceso y el 
    \textit{current working directory}.

    \subsection{Scheduling}
    Como primera estrategia de \textit{scheduling} se decidió implementar una simple estrategia de \textit{Round Robin}.
    Esto es, los períodos de tiempo de uso de CPU (\textit{time slices}) son asignados a los procesos en porciones 
    equivalentes y en orden circular, sin hacer uso de un sistema de prioridades. Este estrategia, además de ser muy 
    fácil de implementar, asegura la provisión de tiempo de CPU a todos los procesos (\textit{starvation free}).

    Para nuestra segunda estrategia, y siguiendo con la consigna del trabajo, implementamos un sistema basado en 
    prioridades. 

    \subsection{Multiples Terminales}
\newpage
\section{Driver Ata}
    Se comenzó a implementar un \textit{driver} ATA en modo PIO. Esto significaba que los accesos a disco iban a ser
    por medio de puertos de entrada/salida. Esto hace que el tiempo de ejecución sea considerable pero era un estandar
    confiable y sencillo de implementar.
    El estandar permite acceder a dos discos simultaneamente pero nosotros no vimos la necesidad de implementar el 
    acceso a más de uno.
    
    El primer paso era detectar el disco y obtener ciertos datos del disco en sí. Por suerte, GRUB provee una estructura
    con varios datos del sistema, entre ellos, datos del disco. Trás leer las especificaciones de \textit{multiboot}
    fue relativamente sencillo realizar este trabajo.

    A la hora de elegir el modo de direccionamiento nos encontramos con tres opciones. CHS se vió descartada de forma
    inmediata dado su estado de obsoleta. Luego existian las opciones de LBA 28 y LBA 48 (sus números representan
    la cantidad de bits relevantes utilizados para la dirección). LBA 28 también estaba obsoleto para ciertos discos
    pero era más rapido, más sencillo de implementar y dejaba satisfechas las necesidades de este trabajo.

    Las unidades minimas de lectura y escritura en nuestra implementación son de a sectores, pudiendo ser de a
    varios a la vez. Es un paso escencial poner los datos correctos en los puertos necesarios previo a los accesos, pero
    es aún más interesante la lectura del estado del disco. Esto es necesario para detectar errores en el disco
    y para saber si el disco esta listo para recibir o enviar datos. Es posible que haya que esperar a que el disco
    este listo antes de realizar alguna operación. Hay dos maneras de realizar esta espera, se puede esperar a que una IRQ
    indique que el disco esta listo o se puede consultar el estado del disco hasta que este este listo (\textit{polling}).
    Hacer \textit{polling} puede hacer que se pierda tiempo en un sistema multitareas, pero por otro lado una sola
    consulta de \textit{polling} es más rápida que esperar a una IRQ e implementar \textit{polling} es mucho más sencillo.
    Por esta última razón fue elegida la técnica de \textit{polling}.
\newpage
\section{File System}
    
    Una vez implementado el \textit{driver} ATA era posible comenzar a implementar nuestro \textit{file system}.
    Dado que nuestra intención era realizar un \textit{file system} persistente debiamos contar con ciertas estructuras
    y ciertas especificaciones de como iba a estar representado el mismo en el disco. Luego de hacer un relevamiento
    en el tópico decidimos que el implementar un sistema de tipo Ext2 abarcaba todas las caracteristicas que deseabamos
    en nuestro sistema. Si bien es posible que un sistema Ext2 exceda los requerimientos del trabajo práctico, decidimos
    que era más seguro seguir este estandar.
    
    Por otro lado, habia que realizar una lógica interna para la representación del \textit{file system}
    incluyendo nuevas prestaciones en las llamadas a sistema y en nuestra libreria estandar. Esta parte de la 
    implementación también es conocida como el \textit{virtual file system} (vfs).

    Una vez terminado el esqueleto que significaba el \textit{file system} se pudo profundizar en el mismo agregando
    nuevas funcionalidades, particularmente vamos a hacer hincapie en las consecuencias de aperturas y manejo de
    archivos, directorios, FIFO's, links simbolicos, \textit{current working
    directory}, permisos del sistema y usuarios y grupos.

    A continuación se presentan secciones detalladas sobre estos puntos.

    \subsection{Sistema Ext2}
    El sistema Ext2 provee un estandar de como guardar la información en el disco. Utiliza conceptos como super bloque, 
    grupo de bloques, bloques y \textit{inodes} (algunos de los cuales fueron vistos en profundidad en clase). Como fue
    dicho anteriormente, seguir este estandar fue una forma ordenada de tener la especificación de toda la estructura
    de nuestro \textit{file system}.

    Fue muy importante para nosotros al leer las especificaciones de Ext2 que todas las consideraciones a tener en cuenta
    para armar nuestro sistema operativo según los requerimientos del trabajo práctico y lo más similar a un ambiente
    UNIX ya estaban especificadas. Por ejemplo, grupos y usuarios pudieron ser usados facilmente. Inclusive, cosas más
    especificas, como si un inode representa un archivo FIFO ya esataban implementadas en Ext2. Si bien fue un trabajo
    largo, ayudó a simplificar el resto de la organización del sistema.

    Hay ciertos detalles interesantes a tener en cuenta sobre la implementación. Sobre el sistema Ext2 se implementaron
    ciertos \textit{buffers} para así disminuir los accesos a disco.

    Ahora veremos la estructura de Ext2 en mayor detalle:

        \subsubsection{Bloques}

        Un \textit{file system} de tipo Ext2 divide el disco en bloques lógicos de sectores contiguos. Esto permite
        tener la información más organizada y provee un sistema especificando como acceder finalmente a cada nodo
        generado.

        \subsubsection{Superbloque}

        Lo primero a realizarse un sistema Ext2 es encontrar y analizar el superbloque. Este contiene toda la información
        necesaria para acceder al sistema. Hay especificaciones sobre como analizar el mismo, que finalmente provee
        toda la información necesaria sobre los grupos de bloques, bloques y nodos.

        \subsubsection{Grupos de bloques}
        
        Para poder tener un acceso más sencillo a la información los bloques se agrupan de a grupos de bloques.
        El superbloque contiene una referencia a la tabla de grupos de bloques. Esta es otro paso necesario a la hora
        de acceder al contenido de un nodo.

        \subsubsection{Inodes}
    
        Un \textit{inode} en el sistema es un nodo que representa cualquier tipo de archivo en el \textit{file system}.
        Estos, contienen todo tipo de información sobre el nodo facilitando así los propositos de nuestro trabajo
        practico. Finalmente, contienen punteros hacia el verdadero contenido del archivo.

        \subsection{Virtual file system}
    
    \subsection{Apertura y manejo de archivos}
    En una primera instancia nos encargamos de adaptar nuestras llamadas a sistema y nuestra librería estandar
    para que puedan desarrollar las nuevas funcionalidades de nuestro sistema operativo. Las llamadas a \textit{read} y
    \textit{write} podían ahora escribir en archivos, así como las llamadas a \textit{open} y \textit{close} se hicieron
    necesarias cuando antes no lo fueron.
    Al hacer una llamada a \textit{open()}, esta actualizaba tanto a nivel kernel como a nivel proceso que cierto
    archivo habia sido abierto. Como ya fue dicho, un proceso contaba con una tabla de \textit{file descriptors}. 
    Estos, apuntan al \textit{inode} siendo manipulado y además cuentan con punteros a función que indican como 
    deben comportarse lecturas y escrituras (entre otras cosas) dependiendo el tipo de archivo 
    (podría bien ser un archivo regular o un link simbolico por ejemplo). Esto permitió que las implementaciones 
    a \textit{read()}, \textit{write()} y \textit{close()} sean bastante sencillas. 
    
    Estas llamadas a sistema fueron siendo extendidas a medida que la funcionalidad del sistema operativo crecía. Como
    será visto en las proximas secciones, se escribieron funciones adecuadas para la manipulación de cada tipo de archivo.
    
    Para realizar todas estas llamadas a sistema se explotó en su máximo potencial las prestaciones del vfs.
    
    Por último, es interesante destacar que dado que el usuario se maneja con cadenas de texto que representan 
    \textit{inodes}, fueron armadas funciones que permiten resolver estas cadenas, dividiendo directorios y archivos,
    proveyendo finalmente el \textit{inode} deseado. 

    \subsection{Directorios}
    
    Ya a bajo nivel era posible detectar el tipo de \textit{inode} guardado en el sistema. Un directorio simplemente era
    un inode que en su contenido se guardan referencias hacía otros inodes. Tanto la interfaz del driver Ext2 como la del
    vfs permiten escribir directorios de forma correcta. Cabe destacar que ademas de la referencia al inode, una entrada
    de directorio también guarda el nombre de la entrada que luego verá el usuario.

    \subsection{FIFO's}

    \subsection{Links simbolicos}
    
    La implementación de links simbolicos implicaba la creación de nodos que inclusive en el sistema Ext2 eran marcados
    como links simbolicos. El contenido de los mismos simplemente indicaba el \textit{path} del archivo al que este
    hacia referencia.
    Luego, a la hora de leer un archivo que sea un link simbolico (o al tratar de resolver un \textit{path} cuyo alguno
    de sus directorios era un link simbolico) bastaba con reemplazar el este archivo con el link al que realmente
    apuntaba.

    En esta implementación (al igual que en el resto) tratamos de ser lo más fieles al entorno \textit{UNIX} como 
    era posible.

    \subsection{Current working directory}
        
    Como ya fue mencionado, cada proceso contiene información sobre cual era el \textit{current working directory} en
    el momento en que fue ejecutado. Esto permite que la obtención del \textit{current working directory} sea sencilla
    y manipulable en los momentos necesarios, sobre todo al modificar el árbol del \textit{file system}.

    \subsection{Usuarios y grupos}
    
    \subsection{Permisos del sistema}

    Una vez implementados usuarios y grupos era fácil saber el gid y el uid de un proceso. Dada la forma en que estaba
    implementado nuestro \textit{file system}, Ext2 contaba con lugares especificos para guardar tanto los permisos y el
    uid y gid del archivo. Además, las prestaciones del vfs hacían que estos datos también fuesen fáciles de obtener.

    Una vez conseguidos estos datos, era trivial evaluar en que casos se permitía abrir un archivo, teniendo en cuenta
    que tanto el archivo tenga los permisos adecuados así como el \textit{path} que lo contiene.

\newpage
\section{Comandos provistos}
    Para poder probar y mostrar las nuevas funcionalidades del trabajo hubo que agregar ciertos comandos y
    funcionalidades ejecutables desde la consola. A continuación se presentan algunos casos interesantes.

\newpage
\section{Problemas encontrados}

Durante el desarrollo de este trabajo practico fueron surgiendo diferentes dudas y problemas. El proposito de esta
sección es comentarlos con el fin del aprendizaje.

Un dilema bastante frecuente a lo largo del trabajo practico es lo que nos gusta llamar "gallina o huevo". Al realizar
un desarrollo a bajo nivel que ha comenzado con pocos recursos, era habitual encontrarse con la duda de si convenía
arrancar a implementar la lectura o la escritura de alguna prestación. Es evidente que si se hacía primero la lectura, 
no había forma de probar su funcionamiento ya que no existía la escritura. Lo mismo sucedía a modo inverso. Si bien 
la solución no era complicada (desarrollar todo) era incomodo y molesto a la hora de encontrar errores ya que los mismos
podían encontrarse en cualquier lado.

Varios problemas interesantes surgieron durante la creación del \textit{driver} ATA. A pesar de que se siguieron
rigurosamente los estándares, se encontró que no todos los emuladores funcionaban de forma correcta con el mismo.
Inclusive, detectamos que el driver no se comportaba de manera deseada al tratar con varios sectores a la vez con lo
cual nos vimos forzados a modificar la lógica interna del driver simulando un acceso a multiples sectores a tráves de
varios accesos de a un sector a la vez.

\newpage     
\section{Referencias}

\begin{itemize}
  \item Material provisto por la cátedra
  \item The C programming language - Kernighan y Ritchie
  \item http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
  \item http://webpages.charter.net/danrollins/techhelp/0087.HTM
  \item http://faydoc.tripod.com/cpu/rdtsc.htm
  \item http://stanislavs.org/helppc/
  \item http://www.linux.it/~rubini/docs/ksys/ksys.html
  \item http://wiki.osdev.org
  \item http://wiki.osdev.org/Detecting\_CPU\_Speed
  \item	http://wiki.osdev.org/CMOS\#Accessing\_CMOS\_Registers
  \item http://wiki.osdev.org/Bootable\_CD
  \item http://wiki.osdev.org/Boot\_sequence\#Easy\_Way\_Out
  \item http://wiki.osdev.org/Ext2
  \item http://wiki.osdev.org/IDE
  \item http://wiki.osdev.org/ATA\_PIO\_Mode
  \item http://en.wikipedia.org/wiki/System\_time\#Retrieving\_system\_time
  \item http://en.wikipedia.org/wiki/Calculating\_the\_day\_of\_the\_week
  \item http://cplusplus.com/
  \item http://github.com/esneider/malloc
\end{itemize}
   
\end{document}
